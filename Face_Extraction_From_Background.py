'''
    Date: 5-5-2021
    Name: Engineer-D
    Idea: OpenCV GrabCut: Foreground Segmentation and Extraction for faces
    Special Thanks: PyImageSearch
'''
# Import the necessary packages
import numpy as np
import argparse
import time
import cv2
import os

# Construct the argument parser and parse the arguments
ap = argparse.ArgumentParser()
ap.add_argument("-i","--image", type=str,\
    default=os.path.sep.join(['images', 'adrian.jpg']),
    help = "Path to input image that we'll apply Grabcut to")
ap.add_argument("-c", "--iter", type=int, default=10,\
    help = "# of Grabcut iterations (larger value ==> slower runtime)")
args = vars(ap.parse_args())

# Load the input image from disk and then allocate memory for the 
# Output mask generated by grabcut -- this mask should have the same
# spatial dimensions as the input image

image = cv2.imread(args['image'])
mask = np.zeros(image.shape[:2], dtype = "uint8")

# Define the bounding box coordinates that approximately define the 
# face region

rect = (151, 43, 236, 368)

# allocate memory for two arrays that the grabcut algorithm internally
# uses when segmenting the foreground from the background

fgModel = np.zeros((1,65), dtype='float')
bgModel = np.zeros((1,65), dtype='float')

# apply GrabCut using the bounding box segmentation method
start = time.time()
(mask, bgModel, fgModel) = cv2.grabCut(image, mask, rect, bgModel,\
    fgModel, iterCount = args['iter'], mode= cv2.GC_INIT_WITH_RECT)
end = time.time()
print("[INFO] applying Grabcut took {:.2f} seconds".format(end - start))

# the output mask has four possible output values, marking each pixel
# in the mask as (1) definite background, (2) definite foregound,
# (3) probable background, and (4) probable foreground

values = (
    ("Definite Background", cv2.GC_BGD),
    ("Probable Background", cv2.GC_PR_BGD),
    ("Definite Foreground", cv2.GC_FGD),
    ("Probable Foreground", cv2.GC_PR_FGD),
)

# loop over the possible Grabcut mask values
for (name, value) in values:
    # construct a mask that's for the current value
    print("[INFO] showing mask for '{}'".format(name))
    valueMask = (mask == value).astype("uint8") * 255

    # display the mask so we can visualize it
    cv2.imshow(name, valueMask)
    cv2.waitKey(0)

# we'll set all definite background and probable background pixels
# to 0 while definite foreground and probable foreground pixels are
# set to 1

outputMask = np.where((mask == cv2.GC_BGD) | (mask == cv2.GC_PR_BGD),\
    0, 1)

# scale the mask from the range [0, 1] to [0, 255]
outputMask = (outputMask * 255).astype('uint8')

# apply a bitwise AND to the image using our mask generated by 
# Grabcut to generate our final output image
output = cv2.bitwise_and(image, image, mask=outputMask)

# Show the input image followed by the mask and output generated 
# by grabcut and bitwise masking

cv2.imshow("Input", image)
cv2.imshow("GrabCut Mask", outputMask)
cv2.imshow("GrabCut Output", output)
cv2.waitKey(0)

'''
def extract_face(image, resize=(224,224)):
    image = cv2.imread(image)

    faces = detector.detect_faces(image)
    x1, y1, width, height = faces[0]['box']
    x2, y2 = x1 + width, y1 + height

    face_boundary = image[y1:y2, x1:x2]

    face_image = cv2.resize(face_boundary, resize)

    return face_image
''' 